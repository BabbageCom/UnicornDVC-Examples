from unicorn import *from ctypes import *from ctypes.wintypes import *import argparsefrom time import sleep
class CallbackHandler(UnicornCallbackHandler):	def __init__(self):		super(CallbackHandler,self).__init__()		self.opened=False		self.received=0		print("CallbackHandler initialized")	def _Connected(self):		print("Connected callback called\n")		return 0	def _Disconnected(self,dwDisconnectCode):		print("Disconnected callback called with dwDisconnectCode %d\n"%dwDisconnectCode)		return 0	def _Terminated(self):		print("Terminated callback called\n")		return 0	def _OnNewChannelConnection(self):		print("OnNewChannelConnection callback called\n")		self.opened=True		return 0	def _OnDataReceived(self,cbSize, pBuffer):		pBuffer=cast(pBuffer,c_wchar_p)		str=pBuffer.value		pBufferSize=(len(str)+1)*sizeof(c_wchar)		assert pBufferSize==cbSize, "size of pBuffer %d not equal to cbSize %d"%(pBufferSize,cbSize)		print("OnDataReceived called with data '%s' of size %d\n"%(str,cbSize))		self.received+=1		return 0	def _OnReadError(self,dwErrorCode):		print("OnReadError callback called with dwErrorCode %d\n"%dwErrorCode)		self.opened=False		return 0	def _OnClose(self):		print("OnClose callback called\n")		self.opened=False		return 0argParser=argparse.ArgumentParser()argParser.add_argument("connectionType",type=int,choices=[0,1],metavar="connection type {0,1}")args=argParser.parse_args()callbackHandler=CallbackHandler()unicorn=Unicorn(args.connectionType, callbackHandler)def main():	print("ACCESS4U UnicornDVC console test application\n")	print("First, try to initialize the library in %s mode\n"%("server" if unicorn.connectionType==0 else "client"))	res =unicorn.Initialize()	if res:		print("Initialize failed: %s\n"%WinError(res))		return res	print("Initialize succeeded, now trying to open the virtual channel.\n")	for i in range(10):		print("Attempt %d"%(i+1))		res=unicorn.Open()		if res:			print("Open failed: %s\n"%WinError(res))			sleep(2.5)			continue		print("Open succeeded\n")		break	else:		print("Open definitely failed\n")		return res	if not callbackHandler.opened:		print("We must wait for the OnNewChannelConnection callback to be called\n")		for i in range(10):			print("Waiting for OnNewChannelConnection call %d/10\n"%(i+1))			sleep(1)			if callbackHandler.opened:				break		else:			print("OnNewChannelConnection call took too long\n")			return 1	print("Sending and receiving pieces of data asynchronously\n")	strings=[		u"(Do!) doe, a deer, a female deer",		u"(Re!) ray, a drop of golden sun",		u"(Mi!) me, a name I call myself",		u"(Fa!) far, a long, long way to run",		u"(So!) sew, a needle pulling thread",		u"(La!) la, a note to follow so",		u"(Ti!) tea, a drink with jam and bread",		u"That will bring us back to do oh oh oh"	]	for string in strings:		print("Writing '%s'\n"%string)		strbuf=create_unicode_buffer(string)		res=unicorn.Write(sizeof(strbuf),cast(strbuf,POINTER(BYTE)))		if (res):			print("Writing '%s' failed: %s\n"%(string,WinError(res)))			return 1	while callbackHandler.received<len(strings) or callbackHandler.opened:		print("Waiting for data, %d chunks received\n"%callbackHandler.received)		sleep(4)	print("We are ready.\n")	if unicorn.connectionType==1: # Client		for i in range(1,10):			if not callbackHandler.opened:				break			print("Waiting for the channel to be closed from the server...\n")			sleep(4)	if callbackHandler.opened:		print("closing channel...\n")		res=unicorn.Close()		if res:			print("Close failed: %s\n"%WinError(res))	print("Terminating library...\n")	res=unicorn.Terminate()	if res:		print("Terminate failed: %s\n"%WinError(res))		return res	print("All done, have a nice day!\n")	return 0if __name__ == "__main__":	main()